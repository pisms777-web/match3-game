<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
  <title>3 –≤ —Ä—è–¥ ‚Äî v2.3</title>
  <meta name="theme-color" content="#e91e63">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="apple-touch-icon" href="https://placehold.co/180x180/e91e63/white?text=3–≤–†—è–¥">
  <link rel="manifest" href="application/manifest+json,{
    %22name%22:%223%20–≤%20—Ä—è–¥%22,
    %22short_name%22:%223–≤–†—è–¥%22,
    %22start_url%22:%22./%22,
    %22display%22:%22standalone%22,
    %22background_color%22:%22%23f0f0f0%22,
    %22theme_color%22:%22%23e91e63%22,
    %22icons%22:[{
      %22src%22:%22https://placehold.co/192x192/e91e63/white?text=3–≤–†—è–¥%22,
      %22sizes%22:%22192x192%22,
      %22type%22:%22image/png%22
    }]
  }">
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 8px 8px 12px;
      background: #f0f0f0;
      font-family: sans-serif;
      overflow: hidden;
      touch-action: none;
    }
    body.dark { background: #1e1e1e; }
    #header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    #score-container { text-align: center; flex: 1; }
    #score, #level, #goal, #high-score {
      font-size: 20px;
      font-weight: bold;
      color: #333;
    }
    body.dark #score,
    body.dark #level,
    body.dark #goal,
    body.dark #high-score {
      color: #f0f0f0;
    }
    #settings-btn {
      background: #2196f3;
      color: white;
      border: none;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 20px;
      cursor: pointer;
    }
    #game {
      position: relative;
      display: grid;
      grid-template-columns: repeat(10, 8.8vw);
      grid-template-rows: repeat(10, 8.8vw);
      gap: 2px;
      background: #333;
      padding: 6px;
      border-radius: 10px;
      margin: 0 auto;
      max-width: 96vw;
    }
    .cell {
      border-radius: 6px;
    }
    body.round .cell {
      border-radius: 50%;
    }
    #dragging-clone {
      position: absolute;
      pointer-events: none;
      z-index: 100;
      transform: translate(-50%, -50%);
    }
    body.round #dragging-clone {
      border-radius: 50%;
    }
    .particle {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      pointer-events: none;
      z-index: 200;
      opacity: 1;
    }
    @keyframes fall {
      from { transform: translateY(-100px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    #notification, #settings {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
    }
    #notification-content, #settings-content {
      background: white;
      padding: 24px;
      border-radius: 12px;
      text-align: center;
      max-width: 80%;
    }
    body.dark #notification-content,
    body.dark #settings-content {
      background: #2a2a2a;
      color: white;
    }
    button {
      padding: 10px 20px;
      background: #2196f3;
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="header">
    <div id="score-container">
      <div id="score">–°—á—ë—Ç: 0</div>
      <div id="level">–£—Ä–æ–≤–µ–Ω—å: 1</div>
      <div id="goal">–¶–µ–ª—å: 500</div>
      <div id="high-score">–†–µ–∫–æ—Ä–¥: 0</div>
    </div>
    <button id="settings-btn">‚öôÔ∏è</button>
  </div>
  <div id="game"></div>
  
  <div id="notification">
    <div id="notification-content">
      <h2 id="notification-text">–£—Ä–æ–≤–µ–Ω—å –ø—Ä–æ–π–¥–µ–Ω!</h2>
      <button id="next-level-btn">–î–∞–ª–µ–µ</button>
    </div>
  </div>
  
  <div id="settings">
    <div id="settings-content">
      <h3>–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h3>
      <label>–§–æ–Ω: 
        <select id="theme-select">
          <option value="light">–°–≤–µ—Ç–ª—ã–π</option>
          <option value="dark">–¢—ë–º–Ω—ã–π</option>
        </select>
      </label><br><br>
      <label>–§–æ—Ä–º–∞ —Ñ–∏—à–µ–∫: 
        <select id="shape-select">
          <option value="square">–ö–≤–∞–¥—Ä–∞—Ç—ã</option>
          <option value="round">–ö—Ä—É–≥–∏</option>
        </select>
      </label><br><br>
      <button id="close-settings">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>
  </div>

  <script>
    // === –ù–ê–°–¢–†–û–ô–ö–ò ===
    let theme = localStorage.getItem('match3Theme') || 'light';
    let shape = localStorage.getItem('match3Shape') || 'square';
    document.body.classList.toggle('dark', theme === 'dark');
    document.body.classList.toggle('round', shape === 'round');
    document.getElementById('theme-select').value = theme;
    document.getElementById('shape-select').value = shape;

    // === –ö–û–ù–°–¢–ê–ù–¢–´ ===
    const ROWS = 10;
    const COLS = 10;
    const COLORS = ['#e91e63', '#4caf50', '#2196f3', '#ff9800'];
    const LEVEL_GOALS = [500, 800, 1200, 1600, 2000, 2500];

    // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
    let score = 0;
    let board = [];
    let isDown = false;
    let startRow = -1;
    let startCol = -1;
    let gameRect = null;
    let cellSize = 0;
    let draggingClone = null;
    let highScore = localStorage.getItem('match3HighScore') ? parseInt(localStorage.getItem('match3HighScore')) : 0;
    let currentLevel = 1;

    // === –§–£–ù–ö–¶–ò–ò ===
    function playSuccessSound() {
      let audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.type = 'sine';
      oscillator.frequency.setValueAtTime(600, audioContext.currentTime);
      oscillator.frequency.exponentialRampToValueAtTime(300, audioContext.currentTime + 0.2);
      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      oscillator.start();
      oscillator.stop(audioContext.currentTime + 0.2);
    }

    function createParticles(x, y, color, count = 8) {
      const gameEl = document.getElementById('game');
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.backgroundColor = color;
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        gameEl.appendChild(particle);
        const angle = Math.random() * Math.PI * 2;
        const speed = 30 + Math.random() * 40;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        let opacity = 1;
        const animate = () => {
          if (opacity <= 0) { particle.remove(); return; }
          const newX = parseFloat(particle.style.left) + vx * 0.02;
          const newY = parseFloat(particle.style.top) + vy * 0.02;
          opacity -= 0.03;
          particle.style.left = `${newX}px`;
          particle.style.top = `${newY}px`;
          particle.style.opacity = opacity;
          requestAnimationFrame(animate);
        };
        requestAnimationFrame(animate);
      }
    }

    function generateBoard() {
      const b = Array(ROWS).fill().map(() => Array(COLS).fill(null));
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          let color;
          do {
            color = COLORS[Math.floor(Math.random() * COLORS.length)];
          } while (
            (r >= 2 && b[r-1][c] === color && b[r-2][c] === color) ||
            (c >= 2 && b[r][c-1] === color && b[r][c-2] === color)
          );
          b[r][c] = color;
        }
      }
      return b;
    }

    function findMatches() {
      const matches = new Set();
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c <= COLS - 3; c++) {
          const col = board[r][c];
          if (col && board[r][c+1] === col && board[r][c+2] === col) {
            let k = c; while (k < COLS && board[r][k] === col) { matches.add(`${r},${k}`); k++; }
          }
        }
      }
      for (let c = 0; c < COLS; c++) {
        for (let r = 0; r <= ROWS - 3; r++) {
          const col = board[r][c];
          if (col && board[r+1][c] === col && board[r+2][c] === col) {
            let k = r; while (k < ROWS && board[k][c] === col) { matches.add(`${k},${c}`); k++; }
          }
        }
      }
      return matches;
    }

    function removeMatchesAndRefill(matches) {
      if (matches.size > 0) {
        playSuccessSound();
        score += matches.size * 10;
        document.getElementById('score').textContent = `–°—á—ë—Ç: ${score}`;
        if (score > highScore) {
          highScore = score;
          localStorage.setItem('match3HighScore', highScore);
          document.getElementById('high-score').textContent = `–†–µ–∫–æ—Ä–¥: ${highScore}`;
        }
        const gameEl = document.getElementById('game');
        const rect = gameEl.getBoundingClientRect();
        matches.forEach(pos => {
          const [r, c] = pos.split(',').map(Number);
          const color = board[r][c];
          const x = rect.left + 6 + c * (cellSize + 2) + cellSize / 2;
          const y = rect.top + 6 + r * (cellSize + 2) + cellSize / 2;
          createParticles(x, y, color);
        });
      }
      matches.forEach(pos => {
        const [r, c] = pos.split(',').map(Number);
        board[r][c] = null;
      });
      for (let c = 0; c < COLS; c++) {
        const colVals = [];
        for (let r = ROWS - 1; r >= 0; r--) {
          if (board[r][c] !== null) colVals.push(board[r][c]);
        }
        while (colVals.length < ROWS) {
          colVals.push(COLORS[Math.floor(Math.random() * COLORS.length)]);
        }
        for (let r = 0; r < ROWS; r++) {
          board[ROWS - 1 - r][c] = colVals[r];
        }
      }
      renderBoard(matches);
      setTimeout(() => {
        const newMatches = findMatches();
        if (newMatches.size > 0) {
          removeMatchesAndRefill(newMatches);
        } else {
          const goal = LEVEL_GOALS[currentLevel - 1];
          if (score >= goal) {
            if (currentLevel < LEVEL_GOALS.length) {
              showNotification(`–£—Ä–æ–≤–µ–Ω—å ${currentLevel} –ø—Ä–æ–π–¥–µ–Ω!`, () => startLevel(currentLevel + 1));
            } else {
              showNotification('–í—Å–µ —É—Ä–æ–≤–Ω–∏ –ø—Ä–æ–π–¥–µ–Ω—ã!', () => startLevel(1));
            }
          }
        }
      }, 400);
    }

    function attemptSwap(r1, c1, r2, c2) {
      [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
      const matches = findMatches();
      if (matches.size === 0) {
        [board[r1][c1], board[r2][c2]] = [board[r2][c2], board[r1][c1]];
        renderBoard();
      } else {
        renderBoard();
        setTimeout(() => removeMatchesAndRefill(matches), 300);
      }
    }

    function renderBoard(highlightMatches = new Set()) {
      const gameEl = document.getElementById('game');
      gameEl.innerHTML = '';
      gameRect = gameEl.getBoundingClientRect();
      const gap = 2;
      cellSize = (gameRect.width - gap * (COLS - 1)) / COLS;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.style.backgroundColor = board[r][c];
          if (highlightMatches.has(`${r},${c}`)) {
            cell.classList.add('falling');
          }
          cell.dataset.row = r;
          cell.dataset.col = c;
          gameEl.appendChild(cell);
        }
      }
    }

    function getCellFromPoint(x, y) {
      if (!gameRect) return null;
      const pad = 6;
      const left = gameRect.left + pad;
      const top = gameRect.top + pad;
      const width = gameRect.width - pad * 2;
      const height = gameRect.height - pad * 2;
      if (x < left || x > left + width || y < top || y > top + height) return null;
      const col = Math.floor((x - left) / (cellSize + 2));
      const row = Math.floor((y - top) / (cellSize + 2));
      if (row >= 0 && row < ROWS && col >= 0 && col < COLS) return { row, col };
      return null;
    }

    function createDraggingClone(color, clientX, clientY) {
      if (draggingClone) draggingClone.remove();
      draggingClone = document.createElement('div');
      draggingClone.id = 'dragging-clone';
      draggingClone.style.width = `${cellSize}px`;
      draggingClone.style.height = `${cellSize}px`;
      draggingClone.style.backgroundColor = color;
      document.body.appendChild(draggingClone);
      updateDraggingPosition(clientX, clientY);
    }

    function updateDraggingPosition(clientX, clientY) {
      if (!draggingClone) return;
      const centerX = gameRect.left + 6 + startCol * (cellSize + 2) + cellSize / 2;
      const centerY = gameRect.top + 6 + startRow * (cellSize + 2) + cellSize / 2;
      let dx = clientX - centerX;
      let dy = clientY - centerY;
      const max = cellSize * 0.9;
      dx = Math.max(-max, Math.min(max, dx));
      dy = Math.max(-max, Math.min(max, dy));
      let finalX = centerX;
      let finalY = centerY;
      if (Math.abs(dx) > Math.abs(dy)) {
        if (dx > cellSize / 3 && startCol < COLS - 1) finalX = centerX + (cellSize + 2);
        else if (dx < -cellSize / 3 && startCol > 0) finalX = centerX - (cellSize + 2);
      } else {
        if (dy > cellSize / 3 && startRow < ROWS - 1) finalY = centerY + (cellSize + 2);
        else if (dy < -cellSize / 3 && startRow > 0) finalY = centerY - (cellSize + 2);
      }
      draggingClone.style.left = `${finalX}px`;
      draggingClone.style.top = `${finalY}px`;
    }

    function removeDraggingClone() {
      if (draggingClone) {
        draggingClone.remove();
        draggingClone = null;
      }
    }

    function startLevel(level) {
      currentLevel = level;
      score = 0;
      document.getElementById('score').textContent = `–°—á—ë—Ç: ${score}`;
      document.getElementById('level').textContent = `–£—Ä–æ–≤–µ–Ω—å: ${level}`;
      document.getElementById('goal').textContent = `–¶–µ–ª—å: ${LEVEL_GOALS[level - 1]}`;
      board = generateBoard();
      renderBoard();
    }

    function showNotification(text, callback) {
      document.getElementById('notification-text').textContent = text;
      document.getElementById('notification').style.display = 'flex';
      document.getElementById('next-level-btn').onclick = () => {
        document.getElementById('notification').style.display = 'none';
        callback();
      };
    }

    // === TOUCH ===
    document.addEventListener('touchstart', e => {
      if (document.getElementById('notification').style.display === 'flex' || 
          document.getElementById('settings').style.display === 'flex') return;
      if (e.touches.length !== 1) return;
      
      // üîë –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û: –æ–±–Ω–æ–≤–∏—Ç—å —Ä–∞–∑–º–µ—Ä—ã –ø–µ—Ä–µ–¥ –Ω–∞—á–∞–ª–æ–º
      renderBoard(); // ‚Üê —ç—Ç–æ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã–π gameRect

      const x = e.touches[0].clientX;
      const y = e.touches[0].clientY;
      const cell = getCellFromPoint(x, y);
      if (!cell) return;
      isDown = true;
      startRow = cell.row;
      startCol = cell.col;
      createDraggingClone(board[startRow][startCol], x, y);
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchmove', e => {
      if (document.getElementById('notification').style.display === 'flex' || 
          document.getElementById('settings').style.display === 'flex') return;
      if (!isDown || e.touches.length !== 1) return;
      const x = e.touches[0].clientX;
      const y = e.touches[0].clientY;
      updateDraggingPosition(x, y);
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', e => {
      if (document.getElementById('notification').style.display === 'flex' || 
          document.getElementById('settings').style.display === 'flex') return;
      if (!isDown) return;
      removeDraggingClone();
      if (e.changedTouches.length === 0) return;
      const x = e.changedTouches[0].clientX;
      const y = e.changedTouches[0].clientY;
      const pad = 6;
      const left = gameRect.left + pad;
      const top = gameRect.top + pad;
      const centerX = left + startCol * (cellSize + 2) + cellSize / 2;
      const centerY = top + startRow * (cellSize + 2) + cellSize / 2;
      const candidates = [
        { r: startRow, c: startCol },
        { r: startRow - 1, c: startCol },
        { r: startRow + 1, c: startCol },
        { r: startRow, c: startCol - 1 },
        { r: startRow, c: startCol + 1 }
      ];
      let best = null;
      let minDist = Infinity;
      for (const cand of candidates) {
        if (cand.r < 0 || cand.r >= ROWS || cand.c < 0 || cand.c >= COLS) continue;
        const cx = left + cand.c * (cellSize + 2) + cellSize / 2;
        const cy = top + cand.r * (cellSize + 2) + cellSize / 2;
        const dist = Math.hypot(x - cx, y - cy);
        if (dist < minDist) {
          minDist = dist;
          best = cand;
        }
      }
      if (best && (best.r !== startRow || best.c !== startCol) &&
          (Math.abs(best.r - startRow) + Math.abs(best.c - startCol) === 1)) {
        attemptSwap(startRow, startCol, best.r, best.c);
      } else {
        renderBoard();
      }
      isDown = false;
      startRow = -1;
      startCol = -1;
    }, { passive: false });

    // === –ù–ê–°–¢–†–û–ô–ö–ò ===
    document.getElementById('settings-btn').onclick = () => {
      document.getElementById('settings').style.display = 'flex';
    };
    document.getElementById('close-settings').onclick = () => {
      document.getElementById('settings').style.display = 'none';
    };
    document.getElementById('theme-select').onchange = (e) => {
      theme = e.target.value;
      localStorage.setItem('match3Theme', theme);
      document.body.classList.toggle('dark', theme === 'dark');
    };
    document.getElementById('shape-select').onchange = (e) => {
      shape = e.target.value;
      localStorage.setItem('match3Shape', shape);
      document.body.classList.toggle('round', shape === 'round');
    };

    // === –°–¢–ê–†–¢ ===
    window.addEventListener('load', () => {
      document.getElementById('high-score').textContent = `–†–µ–∫–æ—Ä–¥: ${highScore}`;
      startLevel(1);
    });
  </script>
</body>
</html>
